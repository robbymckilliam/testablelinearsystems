import numbers.finite.Complex
import numbers.finite.PolarComplex
import numbers.finite.RectComplex
import scala.math.sin
import scala.math.abs
import scala.math.sqrt
import scala.math.min
import scala.math.max
import scala.math.floor
import scala.math.round
import scala.math.ceil
import scala.math.pow
import scala.math.Pi

/** Return element of {0,1,...,y-1} equivalent to x mod y */
def mod(x : Int, y : Int) = (x % y + y) % y

/** The discrete Fourier transform computed directly from the formula */
def directD(N : Int, c : Int => Complex) : Int => Complex = {
  // The discrete time Fourier transform of c
  def Dc(f : Double) = (0 to N-1).foldLeft(Complex.zero)( (s, n) => s + PolarComplex(1,-2*Pi*n*f) * c(n) )
  val d = (0 to N-1).map( k => Dc(k.toDouble/N) )
  k => d(mod(k,N))
}

/** The fast Fourier transform.  Only works for N a power of 2. */
def fft(N : Int, c : Int => Complex) : Int => Complex = {
  if(N==1) return k => c(0)
  if(N%2 != 0) throw new RuntimeException("N must be a power of 2 for this FFT")
  val Dp = fft(N/2, n => c(2*n))
  val Dq = fft(N/2, n => c(2*n+1))
  val d = (0 to N-1).map( k => Dp(k) + PolarComplex(1,-2*Pi*k/N)*Dq(k) ) //write the values for a single period into an array
  k => d(mod(k,N))
}

/** The inverse fast Fourier transform. Only works for N a power of 2. */
def ifft(N : Int, d : Int => Complex) : Int => Complex = {
  val cc = fft(N, k => d(k).conjugate)
  k => cc(k).conjugate/N
}

/** 
JTransforms FFT.  This is an optimised FFT library and should be faster than the algorithm above.
Also works when the length is not a power of 2.
*/
def jfft(N : Int, c : Int => Complex) : Int => Complex = {
  val csamples = (0 to N-1).map( n => c(n) ) //write sequence to array
  val d =numbers.finite.fft.DiscreteFourierTransform.fft(csamples)
  k => d(mod(k,N))
}


/// Now we setup and run some benchmarks with the algorithms above

println("Benchmarking discrete Fourier transforms")

val bench_duration = 5; //time in seconds used for each benchmark

//Run a benchmark on the algorithm alg with data c.
def runbenchmark(alg : ()=>Int=>Complex, starttime : Long=System.nanoTime, itr : Long=1) : Double = {
  alg() //run the algorithm
  val runtime = (System.nanoTime - starttime)*1e-9
  if(runtime > bench_duration) runtime/itr; //if we have we have exceeded the benchmark time return time per dft call
  else runbenchmark(alg,starttime,itr+1); //otherwise run another benchmark
}

//Run benchmarks on algorithm alg with length generated by the sequencee Ns
def runAllBenchmarks(alg: (Int, Int=>Complex)=>(Int=>Complex), Ns : Int => Int, k : Int = 0, list : List[(Int, Double)] = List[(Int,Double)]()) : List[(Int,Double)] = {
val N = Ns(k)
val c = (0 until N).map( i => RectComplex(scala.math.random, scala.math.random) ) //some random data to compute the dft of
val time = runbenchmark( ()=>alg(N,n=>c(n)) )
print(".")
if(time > bench_duration) return (N, time) :: list; //if the time per call to alg exceeds the benchmark duration return the list of benchmark times 
else runAllBenchmarks(alg, Ns, k+1, (N, time) :: list); //otherwise run benchmark with the next largest value of N
}

//write benchmark data in list to file name
def writeDataToFile(list : List[(Int, Double)], name : String) {
  val file = new java.io.FileWriter(name)
  list.foreach( d => file.write(d._1.toString.replace('E', 'e') + "\t" + d._2.toString.replace('E', 'e') + "\n") )
  file.close
}

//now run the benchmarks
print("Benchmarking direct formula ")
val direct_times = runAllBenchmarks(directD, k=>round(pow(2,6+k/2.0)).toInt)
writeDataToFile(direct_times, "direct.csv")
print("\nBenchmarking fft ")
val fft_times = runAllBenchmarks(fft, k=>round(pow(2,6+k)).toInt) //only powers of 2 allowed for this fft
writeDataToFile(fft_times, "fft.csv")
print("\nBenchmarking optimised jfft ")
val jfft_times = runAllBenchmarks(jfft, k=>round(pow(2,6+k/2.0)).toInt)
writeDataToFile(jfft_times, "jfft.csv")
println



/// Below are some tests for functions above

println("Now running some tests on the transforms") 

//test directDN
{
val tol = 1e-7
val N = 4
def c(n : Int) = Complex.one 
val d = directD(N,c)
var pass = (d(0) - N).magnitude < tol
(1 to 3).foldLeft(pass) ( (p,i) => p & d(i).magnitude < tol )
println("directD test 1 " + {if(pass) "PASSED" else "FAILED"} )
}
{
val tol = 1e-3
val N = 3
def c(n : Int) = if( n < N && n >= 0) RectComplex(n+1,0) else Complex.zero 
val d = directD(N,c)
val dmatlab = Array( RectComplex(6,0), RectComplex(-1.5,0.866), RectComplex(-1.5,-0.866) )
val pass = (0 to N-1).foldLeft(true)( (p,i) => p & (d(i) - dmatlab(i)).magnitude < tol )
println("directD test 2 " + {if(pass) "PASSED" else "FAILED"} )
}
{
val tol = 1e-3
val N = 4
def c(n : Int) = if( n < N && n >= 0) RectComplex(n+1,0) else Complex.zero 
val d = directD(N,c)
val dmatlab = Array( RectComplex(10,0), RectComplex(-2,2), RectComplex(-2,0), RectComplex(-2,-2) )
val pass = (0 to N-1).foldLeft(true)( (p,i) => p & (d(i) - dmatlab(i)).magnitude < tol )
println("directDN test 3 " + {if(pass) "PASSED" else "FAILED"} )
}

//test FFT
{
val tol = 1e-7
val N = 4
def c(n : Int) = Complex.one 
val d = fft(N,c)
var pass = (d(0) - N).magnitude < tol
(1 to 3).foldLeft(pass) ( (p,i) => p & d(i).magnitude < tol )
println("fft test 1 " + {if(pass) "PASSED" else "FAILED"} )
}
{
val tol = 1e-3
val N = 4
def c(n : Int) = if( n < N && n >= 0) RectComplex(n+1,0) else Complex.zero 
val d = fft(N,c)
val dmatlab = Array( RectComplex(10,0), RectComplex(-2,2), RectComplex(-2,0), RectComplex(-2,-2) )
val pass = (0 to N-1).foldLeft(true)( (p,i) => p & (d(i) - dmatlab(i)).magnitude < tol )
println("fft test 3 " + {if(pass) "PASSED" else "FAILED"} )
}

//test JTransforms FFT
{
val tol = 1e-7
val N = 4
def c(n : Int) = Complex.one 
val d = jfft(N,c)
var pass = (d(0) - N).magnitude < tol
(1 to 3).foldLeft(pass) ( (p,i) => p & d(i).magnitude < tol )
println("jfft test 1 " + {if(pass) "PASSED" else "FAILED"} )
}
{
val tol = 1e-3
val N = 3
def c(n : Int) = if( n < N && n >= 0) RectComplex(n+1,0) else Complex.zero 
val d = jfft(N,c)
val dmatlab = Array( RectComplex(6,0), RectComplex(-1.5,0.866), RectComplex(-1.5,-0.866) )
val pass = (0 to N-1).foldLeft(true)( (p,i) => p & (d(i) - dmatlab(i)).magnitude < tol )
println("jfft test 2 " + {if(pass) "PASSED" else "FAILED"} )
}
{
val tol = 1e-3
val N = 4
def c(n : Int) = if( n < N && n >= 0) RectComplex(n+1,0) else Complex.zero 
val d = jfft(N,c)
val dmatlab = Array( RectComplex(10,0), RectComplex(-2,2), RectComplex(-2,0), RectComplex(-2,-2) )
val pass = (0 to N-1).foldLeft(true)( (p,i) => p & (d(i) - dmatlab(i)).magnitude < tol )
println("jfft test 3 " + {if(pass) "PASSED" else "FAILED"} )
}

//test inverse FFT
{
val tol = 1e-7
val N = 4
def c(n : Int) = Complex.one 
val d = fft(N,c)
val cinv = ifft(N,d)
val pass = (0 to N-1).foldLeft(true) ( (p,i) => p & (c(i)-cinv(i)).magnitude < tol )
println("Inverse FFT test 1 " + {if(pass) "PASSED" else "FAILED"} )
}
{
val tol = 1e-3
val N = 4
def c(n : Int) = if( n < N && n >= 0) RectComplex(n+1,0) else Complex.zero 
val d = fft(N,c)
val cinv = ifft(N,d)
val pass = (0 until N-1).foldLeft(true) ( (p,i) => p & (c(i)-cinv(i)).magnitude < tol )
println("Inverse FFT test 2 " + {if(pass) "PASSED" else "FAILED"} )
}


println("Scala finished")
